<평균 수행 시간이 O(logN)인 알고리즘>
- 퀵 정렬(Quick Sort), 병합 정렬(Merge Sort), 힙 정렬(Heap Sort)
- 한번 수행될 때마다 정렬되어야 하는 수의 범위가 1/2로 줄어드는 경우
- 퀵 정렬 이외의 다른 알고리즘은 추가적인 메모리가 필요함
- 퀵 정렬은 worst case에서는 n^2가 될 수도 있음.
- 병합정렬 : 처음에 2개씩 묶은 뒤 2개, 4개, ...씩 병합하며 정렬하는 것.

  
<힙 정렬>
- tree 정렬. 배열로 많이 표현함.
- 가장 작은 수가 맨 위면 min heap(오름차순)
- 가장 큰 수가 맨 위면 max heap(내림차순)
- 힙 정렬은 binary tree(이진트리)이기 때문에 평균 수행 시간이 O(logN)이다.
- parent가 자신의 child보다 작아야 한다.
- 우선순위 queue를 구할 때 쓰여진다.(같은 부모의 child끼리는 비교하지 않는다.)

<힙 정렬 계산 순서(min heap 기준)>
1. 일단 비교 숫자를 맨 밑으로 가정한 후
2. 해당 배열에서 부모를 찾는다. 부모를 찾는 법은 자신의 배열위치의 1/2부분에 위치한다.
  *1/2로 나눠야 하기 때문에 0번 인덱스는 쓰지 않는다.
3. 맨 밑에 넣었을 때 해당 자리의 부모와 크기를 비교한다.
4. 만약 부모보다 작은 경우 한단계 위로 올라가 2번부터 다시 실행하며
   부모보다 숫자가 작아질 때 까지 반복한다.

정렬을 완료한 후에는 하나씩 꺼내야 한다. (코드에서 deleteHeap부분)
1. root(맨 위)에 있는 숫자(1번 인덱스)만 꺼낸다.
2. 그리고 맨 마지막에 있는 숫자를 꺼내 맨 위에 올려 child와 비교한다.
3. child중 더 작은 수와 비교하여 자리를 바꾼다.
   이 때도 검색 범위가 1/2씩 줄어들기 때문에 평균 수행 시간이 O(logN)라는 것을 알 수 있다.

![image](https://github.com/1010hy/algorithm/assets/67892327/be711f92-affc-4b48-ba02-65cefa23b09b)


출력 결과
1. min heap
![image](https://github.com/1010hy/algorithm/assets/67892327/5d9b7f83-2252-4cfe-8ab0-e7599815af42)

2. max heap
![image](https://github.com/1010hy/algorithm/assets/67892327/43cc4525-64c3-4628-b916-7f3de9d2d7a7)
